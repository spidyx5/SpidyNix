o#!/usr/bin/env bash
# Script to easily change user settings for SpidyNix
# This script is integrated with the main SpidyNix.sh installer
# Run this script to update your personal settings

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Configuration variables
CONFIG_DIR="/etc/nixos/SpidyNix"
USER_CONFIG_FILE="$CONFIG_DIR/user-config.nix"

# Function to print headers
print_header() {
    echo -e "${BLUE}================================================================${NC}"
    echo -e "${BLUE} $1${NC}"
    echo -e "${BLUE}================================================================${NC}"
}

# Function to print subheaders
print_subheader() {
    echo -e "${CYAN}--- $1 ---${NC}"
}

# Function to print success messages
print_success() {
    echo -e "${GREEN}âœ“ $1${NC}"
}

# Function to print warnings
print_warning() {
    echo -e "${YELLOW}âš  $1${NC}"
}

# Function to print errors
print_error() {
    echo -e "${RED}âœ— $1${NC}"
}

# Function to print info messages
print_info() {
    echo -e "${PURPLE}â„¹ $1${NC}"
}

# Function to configure timezone
configure_timezone() {
    print_subheader "Timezone Configuration"

    # Get current timezone
    CURRENT_TZ=$(timedatectl | grep "Time zone" | awk '{print $3}' || echo "Asia/Singapore")
    echo "Current timezone: $CURRENT_TZ"

    # Ask for new timezone
    echo ""
    echo "Available timezones (first 10):"
    timedatectl list-timezones | head -10
    echo "... (run 'timedatectl list-timezones | grep -i <country>' for more)"
    echo ""
    read -p "Enter new timezone (or press Enter to keep current): " NEW_TZ
    NEW_TZ=${NEW_TZ:-$CURRENT_TZ}

    # Update user config
    USER_CONFIG="${USER_CONFIG}
  myConfig.systemPrefs.timezone = \"$NEW_TZ\";"

    print_success "Timezone set to: $NEW_TZ"
}

# Function to configure keyboard layout
configure_keyboard() {
    print_subheader "Keyboard Configuration"

    # Ask for keyboard layout
    echo ""
    echo "Common keyboard layouts: us, gb, de, fr, es, it, ru, jp, colemak, dvorak"
    read -p "Enter keyboard layout (or press Enter for 'us'): " LAYOUT
    LAYOUT=${LAYOUT:-us}

    # Ask for keyboard variant
    echo ""
    echo "Common variants: (empty), colemak, dvorak, qwerty"
    read -p "Enter keyboard variant (or press Enter for empty): " VARIANT
    VARIANT=${VARIANT:-""}

    # Update user config
    USER_CONFIG="${USER_CONFIG}
  myConfig.systemPrefs.keyboard = {
    layout = \"$LAYOUT\";
    variant = \"$VARIANT\";
  };"

    print_success "Keyboard layout set to: $LAYOUT ($VARIANT)"
}

# Function to configure shell preference
configure_shell() {
    print_subheader "Shell Configuration"

    echo "Available shells:"
    echo "1) Nushell (Modern structured shell) - Default"
    echo "2) Fish (User-friendly shell)"
    echo "3) Zsh (Extended shell)"
    echo "4) Bash (GNU shell)"
    echo "5) All shells"
    echo ""

    read -p "Select shell preference [1-5] (press Enter for Nushell): " SHELL_CHOICE
    SHELL_CHOICE=${SHELL_CHOICE:-1}

    case $SHELL_CHOICE in
        1) SHELL_PREF="nushell" ;;
        2) SHELL_PREF="fish" ;;
        3) SHELL_PREF="zsh" ;;
        4) SHELL_PREF="bash" ;;
        5) SHELL_PREF="all" ;;
        *) SHELL_PREF="nushell" ;;
    esac

    # Update user config
    USER_CONFIG="${USER_CONFIG}
  myConfig.systemPrefs.shell = \"$SHELL_PREF\";"

    print_success "Shell preference set to: $SHELL_PREF"
}

# Function to configure editors
configure_editors() {
    print_subheader "Editors Selection"

    echo "Available editors (multiple selection allowed):"
    echo "1) Helix (Modal editor) - Default"
    echo "2) Neovim (Vim-based)"
    echo "3) VSCode/VSCodium (Visual Studio Code)"
    echo "4) Zed (Modern editor)"
    echo "5) None"
    echo ""

    read -p "Select editors (comma-separated numbers, press Enter for 1): " EDITOR_CHOICES
    EDITOR_CHOICES=${EDITOR_CHOICES:-1}

    local editors_config=""
    IFS=',' read -ra CHOICES <<< "$EDITOR_CHOICES"
    for choice in "${CHOICES[@]}"; do
        case $choice in
            1) editors_config="${editors_config}
      helix = true;" ;;
            2) editors_config="${editors_config}
      neovim = true;" ;;
            3) editors_config="${editors_config}
      vscode = true;" ;;
            4) editors_config="${editors_config}
      zed = true;" ;;
        esac
    done

    if [[ -n "$editors_config" ]]; then
        USER_CONFIG="${USER_CONFIG}
  myConfig.editors = {${editors_config}
  };"
        print_success "Editors configured"
    else
        print_warning "No editors selected"
    fi
}

# Function to configure browsers
configure_browsers() {
    print_subheader "Browser Selection"

    echo "Available browsers (multiple selection allowed):"
    echo "1) Chromium (Google-based)"
    echo "2) Qutebrowser (Keyboard-driven)"
    echo "3) Zen Browser (Firefox-based)"
    echo "4) None"
    echo ""

    read -p "Select browsers (comma-separated numbers, press Enter for none): " BROWSER_CHOICES
    BROWSER_CHOICES=${BROWSER_CHOICES:-4}

    local browsers_config=""
    IFS=',' read -ra CHOICES <<< "$BROWSER_CHOICES"
    for choice in "${CHOICES[@]}"; do
        case $choice in
            1) browsers_config="${browsers_config}
      chromium = true;" ;;
            2) browsers_config="${browsers_config}
      qutebrowser = true;" ;;
            3) browsers_config="${browsers_config}
      zen = true;" ;;
        esac
    done

    if [[ -n "$browsers_config" ]]; then
        USER_CONFIG="${USER_CONFIG}
  myConfig.browsers = {${browsers_config}
  };"
        print_success "Browsers configured"
    else
        print_warning "No browsers selected"
    fi
}

# Function to configure productivity tools
configure_productivity() {
    print_subheader "Productivity Software"

    echo "Available productivity software:"
    echo "1) DaVinci Resolve (Video editing)"
    echo "2) DaVinci Resolve Studio (Full version)"
    echo "3) None"
    echo ""

    read -p "Select productivity software (press Enter for none): " PROD_CHOICE
    PROD_CHOICE=${PROD_CHOICE:-3}

    case $PROD_CHOICE in
        1)
            USER_CONFIG="${USER_CONFIG}
  myConfig.productivity = {
    davinciResolve = true;
    davinciResolveStudio = false;
  };"
            ;;
        2)
            USER_CONFIG="${USER_CONFIG}
  myConfig.productivity = {
    davinciResolve = false;
    davinciResolveStudio = true;
  };"
            ;;
    esac

    print_success "Productivity software configured"
}

# Function to configure hardware
configure_hardware() {
    print_subheader "Hardware Configuration"

    echo "CPU Type (multiple selection allowed):"
    echo "1) Intel"
    echo "2) AMD"
    echo "3) Virtual Machine"
    echo ""

    read -p "Select CPU/hardware types (comma-separated, press Enter for Intel): " HW_CHOICES
    HW_CHOICES=${HW_CHOICES:-1}

    local hw_config=""
    IFS=',' read -ra CHOICES <<< "$HW_CHOICES"
    for choice in "${CHOICES[@]}"; do
        case $choice in
            1) hw_config="${hw_config}
      intel = true;" ;;
            2) hw_config="${hw_config}
      amd = true;" ;;
            3) hw_config="${hw_config}
      vm = true;" ;;
        esac
    done

    echo ""
    echo "GPU Type (multiple selection allowed):"
    echo "1) Intel integrated"
    echo "2) AMD dedicated"
    echo "3) NVIDIA dedicated"
    echo ""

    read -p "Select GPU types (comma-separated, press Enter for Intel): " GPU_CHOICES
    GPU_CHOICES=${GPU_CHOICES:-1}

    IFS=',' read -ra GPU_CHOICES <<< "$GPU_CHOICES"
    for choice in "${GPU_CHOICES[@]}"; do
        case $choice in
            1) hw_config="${hw_config}
      intel = true;" ;;
            2) hw_config="${hw_config}
      amd = true;" ;;
            3) hw_config="${hw_config}
      nvidia = true;" ;;
        esac
    done

    if [[ -n "$hw_config" ]]; then
        USER_CONFIG="${USER_CONFIG}
  myConfig.hardwareType = {${hw_config}
  };"
        print_success "Hardware configured"
    fi
}

# Function to configure virtualization
configure_virtualization() {
    print_subheader "Virtualization Tools"

    echo "Available virtualization tools (multiple selection allowed):"
    echo "1) libvirt/QEMU/KVM (VMs)"
    echo "2) Docker (Containers)"
    echo "3) Podman (Rootless containers)"
    echo "4) Waydroid (Android emulation)"
    echo "5) None"
    echo ""

    read -p "Select virtualization tools (comma-separated, press Enter for libvirt,podman): " VIRT_CHOICES
    VIRT_CHOICES=${VIRT_CHOICES:-1,3}

    local virt_config=""
    IFS=',' read -ra CHOICES <<< "$VIRT_CHOICES"
    for choice in "${CHOICES[@]}"; do
        case $choice in
            1) virt_config="${virt_config}
      libvirt = true;" ;;
            2) virt_config="${virt_config}
      docker = true;" ;;
            3) virt_config="${virt_config}
      podman = true;" ;;
            4) virt_config="${virt_config}
      waydroid = true;" ;;
        esac
    done

    # Check for Docker/Podman conflict
    if [[ "$VIRT_CHOICES" =~ (^|,)2(,|$) ]] && [[ "$VIRT_CHOICES" =~ (^|,)3(,|$) ]]; then
        print_warning "Docker and Podman conflict. Disabling Docker."
        VIRT_CHOICES=${VIRT_CHOICES//2,/}
        virt_config="${virt_config//      docker = true;/}"
    fi

    if [[ -n "$virt_config" ]]; then
        USER_CONFIG="${USER_CONFIG}
  myConfig.virtualizationTools = {${virt_config}
  };"
        print_success "Virtualization tools configured"
    fi
}

# Function to configure window manager and terminal
configure_wm_terminal() {
    print_subheader "Window Manager & Terminal"

    echo "Window Manager:"
    echo "1) Niri (Scrollable tiling) - Default"
    echo "2) None (Basic setup)"
    echo ""

    read -p "Select window manager (press Enter for Niri): " WM_CHOICE
    WM_CHOICE=${WM_CHOICE:-1}

    if [[ $WM_CHOICE -eq 1 ]]; then
        USER_CONFIG="${USER_CONFIG}
  myConfig.wm.niri = true;"
        print_success "Niri window manager enabled"
    fi

    echo ""
    echo "Terminal:"
    echo "1) Kitty (GPU-accelerated) - Default"
    echo "2) None"
    echo ""

    read -p "Select terminal (press Enter for Kitty): " TERM_CHOICE
    TERM_CHOICE=${TERM_CHOICE:-1}

    if [[ $TERM_CHOICE -eq 1 ]]; then
        USER_CONFIG="${USER_CONFIG}
  myConfig.terminals.kitty = true;"
        print_success "Kitty terminal enabled"
    fi
}

# Function to generate user configuration
generate_user_config() {
    print_subheader "Generating User Configuration"

    local config_content="# User Configuration File
# Generated by SpidyNix.sh on $(date)
# This file allows you to customize various system features and preferences

{
${USER_CONFIG}
}
"

    # Ensure config directory exists
    mkdir -p "$CONFIG_DIR"

    # Backup existing config if it exists
    if [[ -f "$USER_CONFIG_FILE" ]]; then
        cp "$USER_CONFIG_FILE" "$USER_CONFIG_FILE.backup.$(date +%Y%m%d_%H%M%S)"
        print_info "Backed up existing user-config.nix"
    fi

    # Write new configuration
    echo "$config_content" > "$USER_CONFIG_FILE"

    print_success "User configuration generated at $USER_CONFIG_FILE"

    # Validate configuration
    if nix-instantiate --parse "$USER_CONFIG_FILE" >/dev/null 2>&1; then
        print_success "Configuration syntax is valid"
    else
        print_error "Configuration syntax error detected"
        return 1
    fi
}

# Main function
main() {
    print_header "SPIDYNIX USER SETTINGS CONFIGURATION"

    echo "This script will help you configure your SpidyNix system."
    echo "Please answer the following questions to customize your system."
    echo ""

    # Configuration steps
    configure_timezone
    configure_keyboard
    configure_shell
    configure_editors
    configure_browsers
    configure_productivity
    configure_hardware
    configure_virtualization
    configure_wm_terminal

    # Generate configuration
    generate_user_config

    echo ""
    print_success "Configuration complete!"
    print_info "Review the generated configuration in $USER_CONFIG_FILE"
    echo ""
    echo -e "${YELLOW}ðŸ”„ Run 'sudo nixos-rebuild switch --flake $CONFIG_DIR#Spidy' to apply changes${NC}"
    echo ""
    echo "Note: Your keyd Colemak-DH settings in Systems/user.nix are preserved."
}

# Run main function
main