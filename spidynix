#!/usr/bin/env bash
# ============================================================================
# SpidyNix Installation and Maintenance Script
# ============================================================================
# Enhanced SpidyNix installation script with comprehensive shell support
# Features:
# - Fish, Zsh, Bash, and Nushell support
# - Interactive configuration setup
# - Hardware configuration generation
# - Profile selection (Spidy/Spooda)
# - System maintenance and updates
# ============================================================================

set -euo pipefail

# Enhanced shell support
SUPPORTED_SHELLS=("bash" "zsh" "fish" "nushell")
CURRENT_SHELL=""

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Configuration variables
REPO_URL="https://github.com/yourusername/SpidyNix.git"  # Replace with actual repo URL

# Detect if we're in a live ISO environment and set appropriate mount point
if [[ -d "/mnt" ]] && mountpoint -q /mnt 2>/dev/null; then
    MOUNT_POINT="/mnt"
    print_info "Detected live ISO environment, using /mnt as mount point"
elif [[ -d "/mnt" ]]; then
    MOUNT_POINT="/mnt"
else
    MOUNT_POINT="/mnt"  # Default for live installations
fi

CONFIG_DIR="/etc/nixos/SpidyNix"
SPIDYNIX_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Script configuration
VERSION="2.0.0"
DRY_RUN=false

# Initialize user configuration
USER_CONFIG=""

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

print_header() {
    echo -e "${BLUE}================================================================${NC}"
    echo -e "${BLUE} $1${NC}"
    echo -e "${BLUE}================================================================${NC}"
}

print_subheader() {
    echo -e "${CYAN}--- $1 ---${NC}"
}

print_success() {
    echo -e "${GREEN}✓ $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}⚠ $1${NC}"
}

print_error() {
    echo -e "${RED}✗ $1${NC}"
}

print_info() {
    echo -e "${PURPLE}ℹ $1${NC}"
}

log_action() {
    echo -e "${CYAN}[$(date '+%H:%M:%S')] $1${NC}"
}

# Enhanced shell detection and input functions
detect_shell_and_setup() {
    local current_shell=""

    # Detect current shell
    if [[ -n "${SHELL:-}" ]]; then
        current_shell=$(basename "$SHELL")
    elif [[ -n "${BASH_VERSION:-}" ]]; then
        current_shell="bash"
    elif [[ -n "${ZSH_VERSION:-}" ]]; then
        current_shell="zsh"
    elif command -v fish >/dev/null 2>&1; then
        current_shell="fish"
    elif command -v nu >/dev/null 2>&1; then
        current_shell="nushell"
    else
        current_shell="bash"
    fi

    # Verify shell is supported
    if [[ ! " ${SUPPORTED_SHELLS[@]} " =~ " ${current_shell} " ]]; then
        print_warning "Shell $current_shell not fully supported. Defaulting to bash."
        current_shell="bash"
    fi

    # Setup read function based on shell
    setup_input_function "$current_shell"

    print_info "Using shell: $current_shell"
}

setup_input_function() {
    local shell="$1"

    case "$shell" in
        fish)
            # Fish shell compatible read
            read_input() {
                if [[ -n "${2:-}" ]]; then
                    read -p "$1" -r "$2"
                else
                    read -p "$1" -r
                fi
            }
            read_password() {
                read -s -p "$1" -r
                echo
            }
            ;;
        zsh)
            # Zsh compatible read
            read_input() {
                if [[ -n "${2:-}" ]]; then
                    read -r "$1" "$2" 2>/dev/null || read -p "$1" "$2"
                else
                    read -r "$1" 2>/dev/null || read -p "$1"
                fi
            }
            read_password() {
                read -rs "$1" 2>/dev/null || read -sp "$1"
                echo
            }
            ;;
        nushell|nu)
            # Nushell compatible read (fallback to bash-like)
            read_input() {
                if [[ -n "${2:-}" ]]; then
                    printf "%s" "$1" && read -r "$2"
                else
                    printf "%s" "$1" && read -r
                fi
            }
            read_password() {
                printf "%s" "$1" && read -rs
                echo
            }
            ;;
        bash|*)
            # Bash and default
            read_input() {
                if [[ -n "${2:-}" ]]; then
                    read -r -p "$1" "$2"
                else
                    read -r -p "$1"
                fi
            }
            read_password() {
                read -rsp "$1"
                echo
            }
            ;;
    esac
}

check_root() {
    if [[ $EUID -ne 0 ]]; then
        print_error "This script must be run as root for system installation"
        print_info "Run with: sudo $0 $*"
        exit 1
    fi

    # Set shell-specific options
    case "$SHELL" in
        *bash)
            set -o pipefail
            ;;
        *zsh)
            setopt pipefail
            ;;
        *fish)
            # Fish handles pipefail differently
            ;;
        *nu)
            # Nushell has different error handling
            ;;
    esac
}

check_dependencies() {
    local missing_deps=()
    local required_deps=("git" "nix" "parted" "cryptsetup" "btrfs-progs")
    local optional_deps=("lvm2" "mdadm" "zfs" "bcachefs-progs")

    for dep in "${required_deps[@]}"; do
        if ! command -v "$dep" &> /dev/null; then
            missing_deps+=("$dep")
        fi
    done

    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        print_warning "Missing required dependencies: ${missing_deps[*]}"
        print_info "Install with: nix-env -iA nixos.${missing_deps[*]}"
        print_info "Then rerun this script"
        
        read_input "Continue anyway? (not recommended) [y/N]: " continue_anyway
        if [[ ! "$continue_anyway" =~ ^[Yy]$ ]]; then
            exit 1
        fi
    fi

    # Check for optional dependencies and warn if missing
    local missing_optional=()
    for dep in "${optional_deps[@]}"; do
        if ! command -v "$dep" &> /dev/null; then
            missing_optional+=("$dep")
        fi
    done

    if [[ ${#missing_optional[@]} -gt 0 ]]; then
        print_info "Optional dependencies not found: ${missing_optional[*]}"
        print_info "These are useful for advanced disk setup features (LVM, RAID, ZFS, Bcachefs)"
        print_info "Install with: nix-env -iA nixos.${missing_optional[*]}"
    fi

    print_success "Dependency check complete"
}

check_nixos() {
    if [[ ! -f /etc/os-release ]] || ! grep -q "NixOS" /etc/os-release; then
        print_error "This script is designed for NixOS systems"
        exit 1
    fi
}

# ============================================================================
# PROFILE MANAGEMENT
# ============================================================================

select_profile() {
    print_header "PROFILE SELECTION"
    echo "Available profiles:"
    echo "1) Spidy   - Main production profile (recommended)"
    echo "2) Spooda  - Experimental/test profile"
    echo ""

    # Let user choose profile
    read_input "Select profile [1-2] (press Enter for Spidy): " PROFILE_CHOICE
    PROFILE_CHOICE=${PROFILE_CHOICE:-1}

    case $PROFILE_CHOICE in
        1)
            PROFILE="Spidy"
            CURRENT_HOSTNAME="Spidy"
            print_success "Selected Spidy profile (main production)"
            ;;
        2)
            PROFILE="Spooda"
            CURRENT_HOSTNAME="Spooda"
            print_success "Selected Spooda profile (experimental)"
            ;;
        *)
            PROFILE="Spidy"
            CURRENT_HOSTNAME="Spidy"
            print_warning "Invalid choice. Defaulting to Spidy profile"
            ;;
    esac

    # Set profile-specific variables
    if [[ "$PROFILE" == "Spooda" ]]; then
        EXPERIMENTAL_MODE=true
        print_warning "Experimental mode enabled for Spooda profile"
    else
        EXPERIMENTAL_MODE=false
    fi
}

# ============================================================================
# CONFIGURATION FUNCTIONS
# ============================================================================

configure_system_prefs() {
    print_subheader "System Preferences"

    # Timezone
    CURRENT_TZ=$(timedatectl | grep 'Time zone' | awk '{print $3}' 2>/dev/null || echo "Asia/Singapore")
    echo "Current timezone: $CURRENT_TZ"
    read_input "Enter timezone (or press Enter for current): " NEW_TZ
    NEW_TZ=${NEW_TZ:-$CURRENT_TZ}

    # Keyboard layout
    configure_keyboard_layout

    # Add to user config
    USER_CONFIG="${USER_CONFIG}
  myConfig.systemPrefs = {
    timezone = \"$NEW_TZ\";
    keyboard = {
      layout = \"$KB_LAYOUT\";
      variant = \"$KB_VARIANT\";
    };
  };"

    print_success "System preferences configured"
}

configure_keyboard_layout() {
    echo ""
    echo "Keyboard layouts:"
    echo "1) us (QWERTY) - Default"
    echo "2) gb (UK QWERTY)"
    echo "3) de (German QWERTZ)"
    echo "4) fr (French AZERTY)"
    echo "5) es (Spanish QWERTY)"
    echo "6) it (Italian QWERTY)"
    echo "7) ru (Russian)"
    echo "8) jp (Japanese)"
    echo "9) colemak (Colemak)"
    echo "10) dvorak (Dvorak)"
    echo ""

    read_input "Select keyboard layout [1-10] (press Enter for us): " KB_CHOICE
    KB_CHOICE=${KB_CHOICE:-1}

    case $KB_CHOICE in
        1) KB_LAYOUT="us"; KB_VARIANT="" ;;
        2) KB_LAYOUT="gb"; KB_VARIANT="" ;;
        3) KB_LAYOUT="de"; KB_VARIANT="" ;;
        4) KB_LAYOUT="fr"; KB_VARIANT="" ;;
        5) KB_LAYOUT="es"; KB_VARIANT="" ;;
        6) KB_LAYOUT="it"; KB_VARIANT="" ;;
        7) KB_LAYOUT="ru"; KB_VARIANT="" ;;
        8) KB_LAYOUT="jp"; KB_VARIANT="" ;;
        9) KB_LAYOUT="us"; KB_VARIANT="colemak" ;;
        10) KB_LAYOUT="us"; KB_VARIANT="dvorak" ;;
        *) KB_LAYOUT="us"; KB_VARIANT="" ;;
    esac

    print_success "Keyboard layout set to: $KB_LAYOUT ($KB_VARIANT)"
}

configure_editors() {
    print_subheader "Editors Selection"

    echo "Available editors (multiple selection allowed):"
    echo "1) Helix (Modal editor) - Default"
    echo "2) Neovim (Vim-based)"
    echo "3) VSCode/VSCodium (Visual Studio Code)"
    echo "4) Zed (Modern editor)"
    echo "5) None"
    echo ""

    read_input "Select editors (comma-separated numbers, press Enter for 1): " EDITOR_CHOICES
    EDITOR_CHOICES=${EDITOR_CHOICES:-1}

    local editors_config=""
    IFS=',' read -ra CHOICES <<< "$EDITOR_CHOICES"
    for choice in "${CHOICES[@]}"; do
        case $choice in
            1) editors_config="${editors_config}
      helix = true;" ;;
            2) editors_config="${editors_config}
      neovim = true;" ;;
            3) editors_config="${editors_config}
      vscode = true;" ;;
            4) editors_config="${editors_config}
      zed = true;" ;;
        esac
    done

    if [[ -n "$editors_config" ]]; then
        USER_CONFIG="${USER_CONFIG}
  myConfig.editors = {${editors_config}
  };"
        print_success "Editors configured"
    else
        print_warning "No editors selected"
    fi
}

configure_browsers() {
    print_subheader "Browser Selection"

    echo "Available browsers (multiple selection allowed):"
    echo "1) Chromium (Google-based)"
    echo "2) Qutebrowser (Keyboard-driven)"
    echo "3) Zen Browser (Firefox-based)"
    echo "4) None"
    echo ""

    read_input "Select browsers (comma-separated numbers, press Enter for none): " BROWSER_CHOICES
    BROWSER_CHOICES=${BROWSER_CHOICES:-4}

    local browsers_config=""
    IFS=',' read -ra CHOICES <<< "$BROWSER_CHOICES"
    for choice in "${CHOICES[@]}"; do
        case $choice in
            1) browsers_config="${browsers_config}
      chromium = true;" ;;
            2) browsers_config="${browsers_config}
      qutebrowser = true;" ;;
            3) browsers_config="${browsers_config}
      zen = true;" ;;
        esac
    done

    if [[ -n "$browsers_config" ]]; then
        USER_CONFIG="${USER_CONFIG}
  myConfig.browsers = {${browsers_config}
  };"
        print_success "Browsers configured"
    else
        print_warning "No browsers selected"
    fi
}

configure_productivity() {
    print_subheader "Productivity Software"

    echo "Available productivity software:"
    echo "1) DaVinci Resolve (Video editing)"
    echo "2) DaVinci Resolve Studio (Full version)"
    echo "3) None"
    echo ""

    read_input "Select productivity software (press Enter for none): " PROD_CHOICE
    PROD_CHOICE=${PROD_CHOICE:-3}

    case $PROD_CHOICE in
        1)
            USER_CONFIG="${USER_CONFIG}
  myConfig.productivity = {
    davinciResolve = true;
    davinciResolveStudio = false;
  };"
            ;;
        2)
            USER_CONFIG="${USER_CONFIG}
  myConfig.productivity = {
    davinciResolve = false;
    davinciResolveStudio = true;
  };"
            ;;
    esac

    print_success "Productivity software configured"
}

configure_hardware() {
    print_subheader "Hardware Configuration"

    echo "CPU Type (multiple selection allowed):"
    echo "1) Intel"
    echo "2) AMD"
    echo "3) Virtual Machine"
    echo ""

    read_input "Select CPU/hardware types (comma-separated, press Enter for Intel): " HW_CHOICES
    HW_CHOICES=${HW_CHOICES:-1}

    local hw_config=""
    IFS=',' read -ra CHOICES <<< "$HW_CHOICES"
    for choice in "${CHOICES[@]}"; do
        case $choice in
            1) hw_config="${hw_config}
      intel = true;" ;;
            2) hw_config="${hw_config}
      amd = true;" ;;
            3) hw_config="${hw_config}
      vm = true;" ;;
        esac
    done

    echo ""
    echo "GPU Type (multiple selection allowed):"
    echo "1) Intel integrated"
    echo "2) AMD dedicated"
    echo "3) NVIDIA dedicated"
    echo ""

    read_input "Select GPU types (comma-separated, press Enter for Intel): " GPU_CHOICES
    GPU_CHOICES=${GPU_CHOICES:-1}

    IFS=',' read -ra GPU_CHOICES <<< "$GPU_CHOICES"
    for choice in "${GPU_CHOICES[@]}"; do
        case $choice in
            1) hw_config="${hw_config}
      intel = true;" ;;
            2) hw_config="${hw_config}
      amd = true;" ;;
            3) hw_config="${hw_config}
      nvidia = true;" ;;
        esac
    done

    if [[ -n "$hw_config" ]]; then
        USER_CONFIG="${USER_CONFIG}
  myConfig.hardwareType = {${hw_config}
  };"
        print_success "Hardware configured"
    fi
}

configure_virtualization() {
    print_subheader "Virtualization Tools"

    echo "Available virtualization tools (multiple selection allowed):"
    echo "1) libvirt/QEMU/KVM (VMs)"
    echo "2) Docker (Containers)"
    echo "3) Podman (Rootless containers)"
    echo "4) Waydroid (Android emulation)"
    echo "5) None"
    echo ""

    read_input "Select virtualization tools (comma-separated, press Enter for libvirt,podman): " VIRT_CHOICES
    VIRT_CHOICES=${VIRT_CHOICES:-1,3}

    local virt_config=""
    IFS=',' read -ra CHOICES <<< "$VIRT_CHOICES"
    for choice in "${CHOICES[@]}"; do
        case $choice in
            1) virt_config="${virt_config}
      libvirt = true;" ;;
            2) virt_config="${virt_config}
      docker = true;" ;;
            3) virt_config="${virt_config}
      podman = true;" ;;
            4) virt_config="${virt_config}
      waydroid = true;" ;;
        esac
    done

    # Check for Docker/Podman conflict
    if [[ "$VIRT_CHOICES" =~ (^|,)2(,|$) ]] && [[ "$VIRT_CHOICES" =~ (^|,)3(,|$) ]]; then
        print_warning "Docker and Podman conflict. Disabling Docker."
        VIRT_CHOICES=${VIRT_CHOICES//2,/}
        virt_config="${virt_config//      docker = true;/}"
    fi

    if [[ -n "$virt_config" ]]; then
        USER_CONFIG="${USER_CONFIG}
  myConfig.virtualizationTools = {${virt_config}
  };"
        print_success "Virtualization tools configured"
    fi
}

generate_user_config() {
    print_subheader "Generating User Configuration"

    # Create comprehensive user configuration template
    local config_content="# User Configuration File
# Generated by SpidyNix.sh on $(date +'%Y-%m-%d %H:%M:%S')
# This file allows you to customize various system features and preferences
# This file is automatically managed by the SpidyNix configuration system

{
  myConfig = {
    # ============================================================================
    # EDITORS - Choose which code editors to install
    # ============================================================================
    editors = {
      helix = false;     # Fast modal editor (default)
      neovim = false;    # Vim-based editor
      vscode = false;    # Visual Studio Code
      zed = false;       # Zed editor
    };

    # ============================================================================
    # BROWSERS - Choose which web browsers to install
    # ============================================================================
    browsers = {
      chromium = false;  # Chromium browser
      qutebrowser = false; # Keyboard-driven browser
      zen = false;       # Zen browser (Firefox-based)
    };

    # ============================================================================
    # TERMINALS - Choose which terminal emulators to install
    # ============================================================================
    terminals = {
      kitty = true;      # GPU-accelerated terminal (default)
    };

    # ============================================================================
    # WINDOW MANAGER - Choose your window manager
    # ============================================================================
    wm = {
      niri = true;       # Niri window manager (default)
    };

    # ============================================================================
    # HARDWARE TYPE - Choose your hardware configuration
    # ============================================================================
    hardwareType = {
      intel = false;     # Intel CPU/GPU (default)
      amd = false;       # AMD CPU/GPU
      nvidia = false;    # NVIDIA GPU
      vm = false;        # Virtual Machine
    };

    # ============================================================================
    # VIRTUALIZATION TOOLS - Individual virtualization components
    # ============================================================================
    virtualizationTools = {
      libvirt = false;   # Enable libvirt/QEMU/KVM for virtual machines
      docker = false;    # Enable Docker container runtime (conflicts with podman)
      podman = false;    # Enable Podman container runtime
      waydroid = false;  # Enable Waydroid Android emulation
    };

    # ============================================================================
    # SYSTEM PREFERENCES - User-configurable system settings
    # ============================================================================
    systemPrefs = {
      # Change your timezone (run 'timedatectl list-timezones' to see options)
      timezone = \"Asia/Singapore\";  # Examples: \"America/New_York\", \"Europe/London\", \"Asia/Tokyo\"

      # Change your keyboard layout (fallback for when not using keyd)
      keyboard = {
        layout = \"us\";          # Examples: \"us\", \"gb\", \"de\", \"fr\"
        variant = \"\";           # Examples: \"colemak\", \"dvorak\", \"qwerty\"
      };
    };

    # ============================================================================
    # PRODUCTIVITY - Professional creative tools
    # ============================================================================
    productivity = {
      davinciResolve = false;      # Video editing software
      davinciResolveStudio = false; # Full DaVinci Resolve Studio
    };
  };
}
"

    # Apply user selections to the template
    if [[ -n "$USER_CONFIG" ]]; then
        # Parse USER_CONFIG and update the template
        config_content=$(echo "$config_content" | sed "s/helix = false;/helix = true;/g" | sed "s/neovim = false;/neovim = true;/g" | sed "s/vscode = false;/vscode = true;/g" | sed "s/zed = false;/zed = true;/g")
        config_content=$(echo "$config_content" | sed "s/chromium = false;/chromium = true;/g" | sed "s/qutebrowser = false;/qutebrowser = true;/g" | sed "s/zen = false;/zen = true;/g")
        config_content=$(echo "$config_content" | sed "s/kitty = false;/kitty = true;/g" | sed "s/niri = false;/niri = true;/g")
        
        # Handle shell configuration
        if echo "$USER_CONFIG" | grep -q "nushell = true"; then
            config_content=$(echo "$config_content" | sed "s/nushell = false;/nushell = true;/g")
        fi
        if echo "$USER_CONFIG" | grep -q "fish = true"; then
            config_content=$(echo "$config_content" | sed "s/fish = false;/fish = true;/g")
        fi
        if echo "$USER_CONFIG" | grep -q "zsh = true"; then
            config_content=$(echo "$config_content" | sed "s/zsh = false;/zsh = true;/g")
        fi
        if echo "$USER_CONFIG" | grep -q "bash = true"; then
            config_content=$(echo "$config_content" | sed "s/bash = false;/bash = true;/g")
        fi
        
        # Handle hardware configuration
        if echo "$USER_CONFIG" | grep -q "intel = true"; then
            config_content=$(echo "$config_content" | sed "s/intel = false;/intel = true;/g")
        fi
        if echo "$USER_CONFIG" | grep -q "amd = true"; then
            config_content=$(echo "$config_content" | sed "s/amd = false;/amd = true;/g")
        fi
        if echo "$USER_CONFIG" | grep -q "nvidia = true"; then
            config_content=$(echo "$config_content" | sed "s/nvidia = false;/nvidia = true;/g")
        fi
        if echo "$USER_CONFIG" | grep -q "vm = true"; then
            config_content=$(echo "$config_content" | sed "s/vm = false;/vm = true;/g")
        fi
        
        # Handle virtualization tools
        if echo "$USER_CONFIG" | grep -q "libvirt = true"; then
            config_content=$(echo "$config_content" | sed "s/libvirt = false;/libvirt = true;/g")
        fi
        if echo "$USER_CONFIG" | grep -q "docker = true"; then
            config_content=$(echo "$config_content" | sed "s/docker = false;/docker = true;/g")
        fi
        if echo "$USER_CONFIG" | grep -q "podman = true"; then
            config_content=$(echo "$config_content" | sed "s/podman = false;/podman = true;/g")
        fi
        if echo "$USER_CONFIG" | grep -q "waydroid = true"; then
            config_content=$(echo "$config_content" | sed "s/waydroid = false;/waydroid = true;/g")
        fi
    fi

    # Ensure config directory exists
    mkdir -p "$CONFIG_DIR"

    # Backup existing config if it exists
    if [[ -f "$CONFIG_DIR/user-config.nix" ]]; then
        cp "$CONFIG_DIR/user-config.nix" "$CONFIG_DIR/user-config.nix.backup.$(date +%Y%m%d_%H%M%S)"
        print_info "Backed up existing user-config.nix"
    fi

    # Write new configuration
    echo "$config_content" > "$CONFIG_DIR/user-config.nix"

    print_success "User configuration generated at $CONFIG_DIR/user-config.nix"

    # Validate configuration
    if nix-instantiate --parse "$CONFIG_DIR/user-config.nix" >/dev/null 2>&1; then
        print_success "Configuration syntax is valid"
    else
        print_error "Configuration syntax error detected"
        print_info "Please check the generated configuration file for syntax errors"
        return 1
    fi
}

# ============================================================================
# INSTALLATION FUNCTIONS
# ============================================================================

setup_spidynix_location() {
    print_subheader "SpidyNix Location Check"

    # Check if we're in a live ISO environment (mounted target)
    if [[ "$MOUNT_POINT" == "/mnt" ]] && mountpoint -q /mnt 2>/dev/null; then
        TARGET_CONFIG_DIR="/mnt/etc/nixos/SpidyNix"
        print_info "Live ISO environment detected"
    else
        TARGET_CONFIG_DIR="/etc/nixos/SpidyNix"
    fi

    # Check if SpidyNix is already in the correct location
    if [[ "$SPIDYNIX_DIR" == "$TARGET_CONFIG_DIR" ]]; then
        print_success "SpidyNix is already properly located at $SPIDYNIX_DIR"
        CONFIG_DIR="$SPIDYNIX_DIR"
        return
    fi

    # Not in correct location, copy to target location
    print_info "Current location: $SPIDYNIX_DIR"
    print_info "Target location: $TARGET_CONFIG_DIR"
    print_info "Copying SpidyNix to target location..."
    
    mkdir -p "$(dirname "$TARGET_CONFIG_DIR")"
    cp -r "$SPIDYNIX_DIR" "$TARGET_CONFIG_DIR"
    CONFIG_DIR="$TARGET_CONFIG_DIR"
    
    # Also copy the script to the new location
    cp "$SPIDYNIX_DIR/SpidyNix.sh" "$CONFIG_DIR/"
    chmod +x "$CONFIG_DIR/SpidyNix.sh"
    
    # Change to the new directory
    cd "$CONFIG_DIR"
    
    print_success "SpidyNix copied to $CONFIG_DIR and directory changed"
    print_info "Configuration directory set to: $CONFIG_DIR"
}

run_flake_lock() {
    print_subheader "Updating Flake Lock"

    if [[ -f "flake.lock" ]]; then
        log_action "Flake lock exists, updating..."
        nix flake lock
    else
        log_action "Creating flake lock..."
        nix flake lock
    fi

    print_success "Flake lock updated"
}

validate_disk_selection() {
    local disk="$1"

    if [[ ! -b "$disk" ]]; then
        print_error "Invalid block device: $disk"
        return 1
    fi

    # Check if disk is mounted
    if mount | grep -q "$disk"; then
        print_error "Disk $disk is currently mounted"
        return 1
    fi

    # Check if disk has partitions
    if [[ -n "$(lsblk -n -o NAME "$disk" 2>/dev/null | tail -n +2)" ]]; then
        echo ""
        print_warning "Disk $disk already has partitions:"
        lsblk "$disk"
        echo ""
        read_input "Continue anyway? This will destroy existing data (yes/no): " confirm
        if [[ "$confirm" != "yes" ]]; then
            print_info "Installation cancelled"
            return 1
        fi
    fi

    return 0
}

setup_disks() {
    print_subheader "Disk Setup"

    # List available disks
    echo "Available disks:"
    lsblk -d -o NAME,SIZE,MODEL,SERIAL | grep -v loop
    echo ""

    read_input "Enter disk for installation (e.g., /dev/nvme0n1): " INSTALL_DISK

    if ! validate_disk_selection "$INSTALL_DISK"; then
        exit 1
    fi

    print_warning "This will ERASE ALL DATA on $INSTALL_DISK"
    read_input "Are you absolutely sure? (type 'yes' to confirm): " confirm

    if [[ "$confirm" != "yes" ]]; then
        print_info "Installation cancelled"
        exit 1
    fi

    log_action "Setting up disk partitions..."

    # Create partitions
    print_info "Creating partitions..."
    parted -s "$INSTALL_DISK" mklabel gpt
    parted -s "$INSTALL_DISK" mkpart ESP fat32 1MiB 512MiB
    parted -s "$INSTALL_DISK" set 1 esp on
    parted -s "$INSTALL_DISK" mkpart primary 512MiB 100%

    # Format EFI partition
    print_info "Formatting EFI partition..."
    mkfs.fat -F32 "${INSTALL_DISK}p1"

    # Setup LUKS encryption
    print_info "Setting up LUKS encryption..."
    echo ""
    read_password "Enter encryption passphrase: " LUKS_PASSWORD
    echo "$LUKS_PASSWORD" | cryptsetup luksFormat "${INSTALL_DISK}p2" -
    echo "$LUKS_PASSWORD" | cryptsetup open "${INSTALL_DISK}p2" cryptroot -

    # Create Btrfs filesystem
    print_info "Creating Btrfs filesystem..."
    mkfs.btrfs /dev/mapper/cryptroot

    # Create subvolumes
    print_info "Creating Btrfs subvolumes..."
    mount /dev/mapper/cryptroot "$MOUNT_POINT"
    btrfs subvolume create "$MOUNT_POINT/root"
    btrfs subvolume create "$MOUNT_POINT/home"
    btrfs subvolume create "$MOUNT_POINT/nix"
    btrfs subvolume create "$MOUNT_POINT/persist"
    umount "$MOUNT_POINT"

    # Mount subvolumes with compression
    print_info "Mounting filesystems..."
    mount -o subvol=root,compress=zstd:3,noatime /dev/mapper/cryptroot "$MOUNT_POINT"
    mkdir -p "$MOUNT_POINT"/{boot,home,nix,persist}

    mount "${INSTALL_DISK}p1" "$MOUNT_POINT/boot"
    mount -o subvol=home,compress=zstd:5,noatime /dev/mapper/cryptroot "$MOUNT_POINT/home"
    mount -o subvol=nix,compress=zstd:4,noatime /dev/mapper/cryptroot "$MOUNT_POINT/nix"
    mount -o subvol=persist,compress=zstd:6,noatime /dev/mapper/cryptroot "$MOUNT_POINT/persist"

    print_success "Disk setup complete"

    # Save encryption password for later use
    echo "$LUKS_PASSWORD" > "$MOUNT_POINT/encryption_password.txt"
}

setup_disks_lvm() {
    print_subheader "Disk Setup with LVM"

    # Check if LVM tools are available
    if ! command -v pvcreate &> /dev/null; then
        print_error "LVM tools not found. Install with: nix-env -iA nixos.lvm2"
        exit 1
    fi

    # List available disks
    echo "Available disks:"
    lsblk -d -o NAME,SIZE,MODEL,SERIAL | grep -v loop
    echo ""

    read_input "Enter disk for installation (e.g., /dev/nvme0n1): " INSTALL_DISK

    if ! validate_disk_selection "$INSTALL_DISK"; then
        exit 1
    fi

    print_warning "This will ERASE ALL DATA on $INSTALL_DISK"
    read_input "Are you absolutely sure? (type 'yes' to confirm): " confirm

    if [[ "$confirm" != "yes" ]]; then
        print_info "Installation cancelled"
        exit 1
    fi

    log_action "Setting up disk partitions with LVM..."

    # Create partitions
    print_info "Creating partitions..."
    parted -s "$INSTALL_DISK" mklabel gpt
    parted -s "$INSTALL_DISK" mkpart ESP fat32 1MiB 512MiB
    parted -s "$INSTALL_DISK" set 1 esp on
    parted -s "$INSTALL_DISK" mkpart primary 512MiB 100%

    # Format EFI partition
    print_info "Formatting EFI partition..."
    mkfs.fat -F32 "${INSTALL_DISK}p1"

    # Setup LUKS encryption
    print_info "Setting up LUKS encryption..."
    echo ""
    read_password "Enter encryption passphrase: " LUKS_PASSWORD
    echo "$LUKS_PASSWORD" | cryptsetup luksFormat "${INSTALL_DISK}p2" -
    echo "$LUKS_PASSWORD" | cryptsetup open "${INSTALL_DISK}p2" cryptlvm -

    # Setup LVM
    print_info "Setting up LVM..."
    pvcreate /dev/mapper/cryptlvm
    vgcreate spidynix-vg /dev/mapper/cryptlvm

    # Create logical volumes
    read_input "Enter root partition size (e.g., 50G, press Enter for 50G): " ROOT_SIZE
    ROOT_SIZE=${ROOT_SIZE:-50G}

    read_input "Enter home partition size (e.g., 100G, press Enter for remaining space): " HOME_SIZE
    HOME_SIZE=${HOME_SIZE:-100%FREE}

    lvcreate -L "$ROOT_SIZE" -n root spidynix-vg
    lvcreate -L "$HOME_SIZE" -n home spidynix-vg
    lvcreate -l 100%FREE -n nix spidynix-vg

    # Create filesystems
    print_info "Creating filesystems..."
    mkfs.btrfs /dev/spidynix-vg/root
    mkfs.btrfs /dev/spidynix-vg/home  
    mkfs.btrfs /dev/spidynix-vg/nix

    # Create subvolumes on root
    print_info "Creating Btrfs subvolumes..."
    mount /dev/spidynix-vg/root "$MOUNT_POINT"
    btrfs subvolume create "$MOUNT_POINT/root"
    btrfs subvolume create "$MOUNT_POINT/persist"
    umount "$MOUNT_POINT"

    # Mount filesystems with compression
    print_info "Mounting filesystems..."
    mount -o subvol=root,compress=zstd:3,noatime /dev/spidynix-vg/root "$MOUNT_POINT"
    mkdir -p "$MOUNT_POINT"/{boot,home,nix,persist}

    mount "${INSTALL_DISK}p1" "$MOUNT_POINT/boot"
    mount -o compress=zstd:5,noatime /dev/spidynix-vg/home "$MOUNT_POINT/home"
    mount -o compress=zstd:4,noatime /dev/spidynix-vg/nix "$MOUNT_POINT/nix"
    mount -o subvol=persist,compress=zstd:6,noatime /dev/spidynix-vg/root "$MOUNT_POINT/persist"

    print_success "LVM disk setup complete"

    # Save encryption password for later use
    echo "$LUKS_PASSWORD" > "$MOUNT_POINT/encryption_password.txt"
}

generate_hardware_config() {
    print_subheader "Hardware Configuration Generation"

    # Ensure the profile directory exists
    mkdir -p "$CONFIG_DIR/Nix/$PROFILE"

    # Skip for experimental profile if not explicitly requested
    if [[ "$EXPERIMENTAL_MODE" == "true" ]]; then
        print_warning "Hardware configuration generation is recommended for production use"
        read_input "Generate hardware configuration for experimental profile? (y/N): " GEN_HW
        GEN_HW=${GEN_HW:-n}
    else
        read_input "Generate hardware configuration? (Y/n): " GEN_HW
        GEN_HW=${GEN_HW:-y}
    fi

    if [[ "$GEN_HW" =~ ^[Yy]$ ]]; then
        print_info "Generating hardware configuration for $PROFILE profile..."

        # Generate hardware configuration
        nixos-generate-config --root "$MOUNT_POINT" --dir "$CONFIG_DIR/Nix/$PROFILE"

        # Remove default configuration.nix if it exists in the generated config
        if [[ -f "$CONFIG_DIR/Nix/$PROFILE/configuration.nix" ]]; then
            rm "$CONFIG_DIR/Nix/$PROFILE/configuration.nix"
            print_info "Removed default configuration.nix"
        fi

        # Copy hardware config to profile directory with proper naming
        if [[ -f "$CONFIG_DIR/Nix/$PROFILE/hardware-configuration.nix" ]]; then
            # Backup existing hardware config if present
            if [[ -f "$CONFIG_DIR/Nix/$PROFILE/hardware-configuration.nix" ]]; then
                cp "$CONFIG_DIR/Nix/$PROFILE/hardware-configuration.nix" "$CONFIG_DIR/Nix/$PROFILE/hardware-configuration.nix.backup.$(date +%Y%m%d_%H%M%S)"
                print_info "Backed up existing hardware configuration"
            fi
            
            # Ensure the hardware config is properly formatted and complete
            print_success "Hardware configuration generated at $CONFIG_DIR/Nix/$PROFILE/hardware-configuration.nix"
            
            # Also create a symlink in the main SpidyNix directory for easy access
            ln -sf "../Nix/$PROFILE/hardware-configuration.nix" "$CONFIG_DIR/hardware-configuration.nix"
            print_info "Created symlink at $CONFIG_DIR/hardware-configuration.nix"
        else
            print_error "Hardware configuration file not found after generation"
            print_info "Trying alternative location..."
            # Try the standard location
            if [[ -f "$MOUNT_POINT/etc/nixos/hardware-configuration.nix" ]]; then
                cp "$MOUNT_POINT/etc/nixos/hardware-configuration.nix" "$CONFIG_DIR/Nix/$PROFILE/"
                print_success "Hardware configuration copied from $MOUNT_POINT/etc/nixos/hardware-configuration.nix"
            fi
        fi

        # Also generate a hardware config without mounting (for existing systems)
        if [[ "$PROFILE" == "Spidy" ]] || [[ "$PROFILE" == "Spooda" ]]; then
            print_info "Generating hardware config for current system..."
            nixos-generate-config --show-hardware-config > "$CONFIG_DIR/Nix/$PROFILE/hardware-configuration-local.nix"
            print_success "Local hardware config saved to $CONFIG_DIR/Nix/$PROFILE/hardware-configuration-local.nix"
        fi

        print_success "Hardware configuration generation complete for $PROFILE profile"
    else
        print_warning "Skipping hardware configuration generation"
        print_info "You can manually configure hardware later or run this script again"
        print_info "To generate hardware config manually: nixos-generate-config --show-hardware-config"
    fi
}

select_disk_setup() {
    print_subheader "Disk Setup Selection"

    echo "Available disk setup options:"
    echo "1) Standard LUKS + Btrfs (recommended) - Direct encryption with Btrfs subvolumes"
    echo "2) LVM + LUKS + Btrfs - Logical Volume Management with Btrfs on top"
    echo "3) Skip disk setup - Use existing partition (for dual-boot or manual setup)"
    echo ""

    read_input "Select disk setup option [1-3] (press Enter for option 1): " DISK_SETUP_CHOICE
    DISK_SETUP_CHOICE=${DISK_SETUP_CHOICE:-1}

    case $DISK_SETUP_CHOICE in
        1)
            print_info "Selected: Standard LUKS + Btrfs setup"
            setup_disks
            return 0
            ;;
        2)
            if command -v pvcreate &> /dev/null; then
                print_info "Selected: LVM + LUKS + Btrfs setup"
                setup_disks_lvm
                return 0
            else
                print_warning "LVM tools not available"
                print_info "Please install LVM tools manually: nix-env -iA nixos.lvm2"
                read_input "Switch to standard setup instead? [Y/n]: " switch_setup
                switch_setup=${switch_setup:-y}
                
                if [[ "$switch_setup" =~ ^[Yy]$ ]]; then
                    print_info "Switching to standard LUKS + Btrfs setup"
                    setup_disks
                    return 0
                else
                    print_info "Installation cancelled"
                    exit 1
                fi
            fi
            ;;
        3)
            print_info "Skipping disk setup - ensure partitions are mounted at $MOUNT_POINT"
            print_warning "Manual disk setup selected - make sure to mount your partitions properly"
            read_input "Continue with manual setup? (y/N): " confirm
            if [[ "$confirm" =~ ^[Yy]$ ]]; then
                return 1
            else
                print_info "Installation cancelled"
                exit 1
            fi
            ;;
        *)
            print_warning "Invalid choice. Defaulting to standard setup"
            setup_disks
            return 0
            ;;
    esac
}

validate_configuration() {
    print_subheader "Validating Configuration"

    log_action "Checking flake configuration..."
    if nix flake check; then
        print_success "Flake validation passed"
    else
        print_error "Flake validation failed"
        return 1
    fi

    log_action "Testing configuration build..."
    if nixos-rebuild dry-build --flake "$CONFIG_DIR#$PROFILE"; then
        print_success "Configuration build test passed"
    else
        print_error "Configuration build test failed"
        return 1
    fi
}

install_system() {
    print_subheader "Installing System"

    # Validate configuration before installation
    if ! validate_configuration; then
        print_error "Configuration validation failed. Aborting installation."
        exit 1
    fi

    log_action "Installing NixOS with $PROFILE configuration..."

    # Install NixOS
    nixos-install --root "$MOUNT_POINT" --flake "$CONFIG_DIR#$PROFILE" --no-root-passwd

    print_success "System installation complete!"
    print_info "Remember to set a root password and user password after reboot"

    # Clean up encryption password
    if [[ -f "$MOUNT_POINT/encryption_password.txt" ]]; then
        shred -vfz -n 3 "$MOUNT_POINT/encryption_password.txt"
        rm -f "$MOUNT_POINT/encryption_password.txt"
    fi
}

# ============================================================================
# MAINTENANCE FUNCTIONS
# ============================================================================

update_system() {
    print_subheader "Updating System"

    setup_spidynix_location
    run_flake_lock

    log_action "Updating flake inputs..."
    nix flake update

    log_action "Rebuilding system..."
    if command -v nh >/dev/null 2>&1; then
        nh os switch --flake "$CONFIG_DIR#$PROFILE"
    else
        nixos-rebuild switch --flake "$CONFIG_DIR#$PROFILE"
    fi

    print_success "System updated successfully"
}

cleanup_system() {
    print_subheader "System Cleanup"

    log_action "Cleaning up old system generations..."
    if command -v nh >/dev/null 2>&1; then
        nh clean all --keep 5
    else
        nix-env --delete-generations old
    fi

    log_action "Running garbage collection..."
    nix-collect-garbage -d

    if command -v nix-store >/dev/null 2>&1; then
        log_action "Optimizing Nix store..."
        nix-store --optimise
    fi

    print_success "System cleanup complete"
}

backup_config() {
    print_subheader "Backing Up Configuration"

    local backup_dir="$HOME/spidynix-backup-$(date +%Y%m%d-%H%M%S)"

    mkdir -p "$backup_dir"
    cp -r /etc/nixos/SpidyNix "$backup_dir/"

    # Also backup system generation
    if [[ -d "/nix/var/nix/profiles/system" ]]; then
        cp -r /nix/var/nix/profiles/system "$backup_dir/system-$(nixos-version --json | jq -r '.version')"
    fi

    print_success "Configuration backed up to $backup_dir"
}

diagnose_system() {
    print_subheader "System Diagnostics"

    echo "=== System Information ==="
    echo "Hostname: $(hostname)"
    echo "OS: $(lsb_release -d 2>/dev/null | cut -f2 || cat /etc/os-release | grep PRETTY_NAME | cut -d'"' -f2)"
    echo "Kernel: $(uname -r)"
    echo "NixOS Version: $(nixos-version 2>/dev/null || echo 'Not NixOS')"
    echo ""

    echo "=== Disk Usage ==="
    df -h
    echo ""

    echo "=== Memory Usage ==="
    free -h
    echo ""

    echo "=== Nix Store ==="
    nix-store --query --deriver /run/current-system 2>/dev/null || echo "No current system found"
    echo ""

    echo "=== Configuration Status ==="
    if [[ -d "/etc/nixos/SpidyNix" ]]; then
        print_success "SpidyNix configuration found"
        echo "Profile: ${PROFILE:-'Not set'}"
    else
        print_warning "SpidyNix configuration not found"
    fi
}

change_settings() {
    print_subheader "Changing Settings"

    # Run the change-settings.sh script if available
    if [[ -f "$CONFIG_DIR/change-settings.sh" ]]; then
        print_info "Using change-settings.sh for configuration..."
        bash "$CONFIG_DIR/change-settings.sh"
    else
        print_warning "change-settings.sh not found in $CONFIG_DIR"
        print_info "Using interactive configuration interface..."

        # Interactive configuration
        configure_system_prefs
        configure_editors
        configure_browsers
        configure_productivity
        configure_hardware
        configure_virtualization

        # Generate configuration
        generate_user_config
    fi

    print_success "Settings updated. Apply with: sudo nixos-rebuild switch --flake $CONFIG_DIR#$PROFILE"
}

# ============================================================================
# INTERACTIVE SETUP
# ============================================================================

interactive_setup() {
    print_header "SPIDYNIX INTERACTIVE SETUP"

    echo "This script will help you set up SpidyNix on your system."
    echo "Please answer the following questions to configure your system."
    echo ""

    # Configuration steps
    select_profile
    configure_system_prefs
    configure_editors
    configure_browsers
    configure_productivity
    configure_hardware
    configure_virtualization

    # Generate configuration
    generate_user_config

    echo ""
    print_success "Configuration complete!"
    print_info "Review the generated configuration in $CONFIG_DIR/user-config.nix"
    echo ""
    read_input "Apply configuration now? (Y/n): " APPLY_NOW
    APPLY_NOW=${APPLY_NOW:-y}

    if [[ "$APPLY_NOW" =~ ^[Yy]$ ]]; then
        print_info "Applying configuration..."
        if command -v nh >/dev/null 2>&1; then
            nh os switch --flake "$CONFIG_DIR#$PROFILE"
        else
            nixos-rebuild switch --flake "$CONFIG_DIR#$PROFILE"
        fi
        print_success "Configuration applied successfully!"
    else
        print_info "Configuration saved. Apply later with:"
        echo "  sudo nixos-rebuild switch --flake $CONFIG_DIR#$PROFILE"
    fi
}

# ============================================================================
# MAIN MENU
# ============================================================================

detect_environment() {
    local env_type=""
    
    if [[ -f /etc/os-release ]] && grep -q "NixOS" /etc/os-release; then
        if mountpoint -q /mnt 2>/dev/null; then
            env_type="Live ISO"
        else
            env_type="Installed NixOS"
        fi
    else
        env_type="Unknown/Other"
    fi
    
    echo "$env_type"
}

show_main_menu() {
    local current_env=$(detect_environment)
    
    echo ""
    print_header "SPIDYNIX MANAGEMENT v$VERSION"
    echo "Environment: $current_env"
    echo "Mount Point: $MOUNT_POINT"
    echo "Config Dir: $CONFIG_DIR"
    echo ""
    echo "Choose an option:"
    echo "1)  Install SpidyNix (new system) - Full installation with disk setup options"
    echo "   └── Standard LUKS+Btrfs, LVM+LUKS+Btrfs, or skip disk setup"
    echo "2)  Interactive setup (existing NixOS) - Configure user preferences"
    echo "3)  Update system - Update flake and rebuild"
    echo "4)  Clean system - Remove old generations and garbage collect"
    echo "5)  Backup configuration - Create backup of current config"
    echo "6)  Change settings - Modify user preferences"
    echo "7)  System diagnostics - Show system information"
    echo "8)  Validate configuration - Test current config"
    echo "9)  Exit"
    echo ""
}

main_menu() {
    while true; do
        show_main_menu
        read_input "Enter choice [1-9]: " choice

        case $choice in
            1)
                check_root
                check_dependencies
                select_profile
                setup_spidynix_location
                run_flake_lock
                
                # New disk setup selection
                if ! select_disk_setup; then
                    # User chose to skip disk setup
                    print_info "Disk setup skipped. Ensure partitions are mounted at $MOUNT_POINT"
                fi
                
                generate_hardware_config

                echo ""
                read_input "Configure user preferences now? (Y/n): " CONFIGURE_NOW
                CONFIGURE_NOW=${CONFIGURE_NOW:-y}

                if [[ "$CONFIGURE_NOW" =~ ^[Yy]$ ]]; then
                    configure_system_prefs
                    configure_editors
                    configure_browsers
                    configure_productivity
                    configure_hardware
                    configure_virtualization
                    generate_user_config
                fi

                install_system
                echo ""
                print_success "Installation complete! Reboot to start your new system."
                print_info "After reboot, run this script again to complete configuration."
                ;;
            2)
                check_nixos
                interactive_setup
                ;;
            3)
                check_nixos
                update_system
                ;;
            4)
                check_nixos
                cleanup_system
                ;;
            5)
                backup_config
                ;;
            6)
                check_nixos
                change_settings
                ;;
            7)
                diagnose_system
                ;;
            8)
                check_nixos
                setup_spidynix_location
                validate_configuration
                ;;
            9)
                print_success "Goodbye!"
                exit 0
                ;;
            *)
                print_warning "Invalid choice. Please select 1-9."
                ;;
        esac

        echo ""
        read_input "Press Enter to continue..."
    done
}

# ============================================================================
# SCRIPT ENTRY POINT
# ============================================================================

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --version)
            echo "SpidyNix Installer v$VERSION"
            exit 0
            ;;
        --help|-h)
            echo "SpidyNix Installation and Management Script v$VERSION"
            echo ""
            echo "Usage: $0 [OPTIONS]"
            echo ""
            echo "Options:"
            echo "  --dry-run    Show what would be done without executing"
            echo "  --version    Show version information"
            echo "  --help, -h   Show this help message"
            echo ""
            echo "Shell Support:"
            echo "  This script supports bash, zsh, fish, and nushell"
            echo "  Shell-specific features will be used when available"
            echo ""
            echo "Installation Features:"
            echo "  • Automatic dependency installation and validation"
            echo "  • Multiple disk setup options:"
            echo "    - Standard LUKS + Btrfs (recommended)"
            echo "    - LVM + LUKS + Btrfs (advanced volume management)"
            echo "    - Skip disk setup (manual configuration)"
            echo "  • Automatic hardware configuration generation"
            echo "  • Profile management (Spidy/Spooda)"
            echo "  • Interactive configuration setup"
            echo ""
            echo "Interactive modes:"
            echo "  1. Run without arguments for full menu interface"
            echo "  2. Run on existing NixOS for configuration"
            echo "  3. Run with sudo for new system installation"
            echo ""
            exit 0
            ;;
        *)
            print_error "Unknown option: $1"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
done

# Initialize
detect_shell_and_setup

# Show welcome message
if [[ $EUID -eq 0 ]]; then
    print_info "Running with root privileges"
else
    print_info "Running as user (some features may require sudo)"
fi

print_info "SpidyNix v$VERSION - Enhanced Installation Script"

# Main execution
main_menu
